<!DOCTYPE html>
<html>
<head>
<title>Test collisions</title>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body{background-color:#BB8;margin:0px;overflow:hidden;text-align:center;}
canvas{margin:auto;border:solid 1px #111}
#dbg{background-color:#FFF;width:250px;}
</style>
</head>
<body>
<div id="dbg">debug</div>
<script>
var bigNumber=1e6, epsilon = 0.001;
var mouse={down:false};
var running=false;
var context;
var frameCount=0;
var pong = {
	balls:[]
	,walls:[]
	,obstacles:[]
	,rackets:[]
};
function start(){
	var W=window.innerWidth,H=window.innerHeight,min=Math.floor(0.95*Math.min(W,H));
	var canvas = document.createElement('canvas');
	canvas.width=min;canvas.height=min;
	context=canvas.getContext('2d');context.translate(min/2,min/2);context.scale(min/2,-min/2);
	context.fillStyle="white";context.lineWidth=0.002;
	document.body.appendChild(canvas);
	
	var pts=[
		new Vector(-1,1)
		,new Vector(1,1)
		,new Vector(1,-1)
		,new Vector(-1,-1)
		,new Vector(0.2,0.4)
		,new Vector(0.4,-0.1)
		,new Vector(0.5,0.4)
		,new Vector(0.8,0.7)
	];
	
	//drawBall(context,{x:0,y:0},0.05);
	//pong.balls.push(new Ball({radius:0.05,coeffRebond:1,position:new Vector(0.12,0),speed:new Vector().randomize().setLength(0.05)}));
	pong.balls.push(new Ball({radius:0.05,coeffRebond:1,position:new Vector(0.4,-0.5),speed:new Vector(0,1).setLength(0.002)}));
	
	//pong.balls.push(new Ball({radius:0.02,coeffRebond:0.98,position:new Vector(0.12,0),speed:new Vector().randomize().setLength(0.07)}));
	
	//pong.balls.push(new Ball({position:new Vector(0,0),speed:new Vector(-0.05+0.1*Math.random(),-0.05+0.1*Math.random())}));
	console.log("start speed : "+pong.balls[0].speed.x+","+pong.balls[0].speed.y);
	pong.walls.push(new Segment({start:pts[0],end:pts[1],rebond:true}));
	pong.walls.push(new Segment({start:pts[1],end:pts[2],rebond:true}));
	pong.walls.push(new Segment({start:pts[2],end:pts[3],rebond:true}));
	pong.walls.push(new Segment({start:pts[3],end:pts[0],rebond:true}));
	pong.walls.push(new Segment({start:pts[4],end:pts[5],rebond:true}));
	pong.walls.push(new Segment({start:pts[6],end:pts[5],rebond:true}));
	pong.walls.push(new Segment({start:pts[4],end:pts[6],rebond:true}));
	//pong.walls.push(new Segment({start:pts[7],end:pts[6],rebond:true}));
	
	
	console.log(pong.balls, pong.walls);
	nextFrame();
	canvas.addEventListener("click",function(e){running=!running;nextFrame();},false);
	
	//canvas.addEventListener("click",nextFrame,false);
	//canvas.addEventListener("mousedown",function(e){mouse.down=true;},false);
	//window.addEventListener("mouseup",function(e){mouse.down=false;},false);
}

function drawBall(context,pos,radius){
	context.moveTo(pos.x+radius,pos.y);
	context.arc(pos.x,pos.y,radius,0,2*Math.PI);
}
function drawBall2(pos,radius,color){
	context.strokeStyle=color;
	context.beginPath();
	context.moveTo(pos.x+radius,pos.y);
	context.arc(pos.x,pos.y,radius,0,2*Math.PI);
	context.stroke();
}
function drawLine(start,end,color){
	context.strokeStyle=color;
	context.beginPath();
	context.moveTo(start.x,start.y);
	context.lineTo(end.x,end.y);
	context.stroke();
}
function drawWall(wall){
	drawLine(wall.start,wall.end,"black");
}
function drawObstacles(context,obstacles){
	context.fillStyle="grey";
	context.beginPath();
	obstacles.forEach(drawObstacle);
	context.fill();
	
	function drawObstacle(obstacle){
		var s=obstacle.segments[0];
		
	}
}
function nextFrame(){
	//if(frameCount<15000) requestAnimationFrame(nextFrame);
	if(running) requestAnimationFrame(nextFrame);
	if(frameCount==14999) console.log("stop");
	context.clearRect(-1,-1,2,2);
	collision2();//and maj
	//drawBall(context,pong.balls[0].position,pong.balls[0].radius);
	context.fillStyle="white";
	context.beginPath();
	pong.balls.forEach(function(b){
		//drawBall(context,b.position,b.radius);
	});
	context.fill();
	pong.walls.forEach(function(wall){
		drawWall(wall);
	});
	frameCount++;
}
function collision2(){//maj position incluse, test sur trajectoire
	pong.balls.forEach(function(ball){
		var savedPosition=ball.position.clone();
		var futurePosition=savedPosition.clone().add(ball.speed);
		var numberOfCollisions=0;
		var fc=[];
	
		pong.walls.forEach(function(wall,index){//doit stopper après le 1er ???
			var collision=wall.testCollision(ball,ball.position,futurePosition);
			if(collision.hitNext){
				numberOfCollisions++;
				fc.push({index:index,np:collision.newPos,nv:collision.newSpeed,pos:collision.positionOnTouch});
			}
		});
		
		if(numberOfCollisions>2) console.log("collision triple darnitr");
		if(numberOfCollisions){
			var fc0=fc[0];
			S("dbg").innerHTML = numberOfCollisions+" collision!!!  "+"  "+fc.length;
			setTimeout(function(){S("dbg").innerHTML ="--";},2000);
			if(numberOfCollisions===1) console.log("simple collision");
			if(numberOfCollisions==2){
				console.log("collision double hahahahihihuhuhuhuhauhohohoho");
				var wall1=pong.walls[fc[0].index];
				var wall2=pong.walls[fc[1].index];
				var pc=wall1.pointDeRencontre(wall2.start,wall2.end).pc;
				var pt1=fc[0].pos.clone();
				var pt2=fc[1].pos.clone();
				var d1=pt1.sub(ball.position).getSqLength();
				var d2=pt2.sub(ball.position).getSqLength();
				if(d1>d2){fc0=fc[1];}
			}
			var nnc=0;
			var ffc=[];
			ball.position.copy(fc0.np);
			ball.speed.copy(fc0.nv);
			pong.walls.forEach(function(wall,index){
				collision=wall.testCollision(ball,fc0.pos,fc0.np);
				if(collision.hitNext){
					nnc++;
					ffc.push({index:index,np:collision.newPos});
				}
			});
			if(nnc>1) console.log("WTFFF");
			if(nnc>0){
				var ffc0=ffc[0];
				var wall=pong.walls[ffc0.index];
				ball.position.copy(ffc0.np);
				ball.speed.copy(wall.bounceVector(ball.speed).multiplyScalar(ball.coeffRebond*wall.coeffRebond));
			}
		}
		if(!numberOfCollisions){
			ball.position.add(ball.speed);//.maj
		}
		
	});
	
}
function Segment(params){//point+normal ??
	//séparer dynamique ou non, même fct par frame
	this.start=params.start;
	this.end=params.end;
	this.directeur=new Vector(this.end.x-this.start.x,this.end.y-this.start.y).normalize();
	this.normal=new Vector(this.directeur.y,-this.directeur.x).normalize();//à droite (yd,-xd) ou (coeff,-1)
	this.coeffRebond=params.coeffRebond||1;
	this.rebond=params.rebond||false;
	//this.touchPoint={};//pos balle au contact
}
Segment.prototype.bounceVector = function(v){
	return v.clone().add(this.normal.clone().multiplyScalar(this.normal.dot(v)).multiplyScalar(-2));
}
Segment.prototype.pointDeRencontre=function(pos1,pos2){
	
	var ballSpeed=new Vector(pos2.x-pos1.x,pos2.y-pos1.y);//"vitesse" ou pas
	var db=ballSpeed.x==0?bigNumber:ballSpeed.y/ballSpeed.x;//iughikulghkl
	var ob=pos2.y-db*pos2.x;
	var ds=this.end.x==this.start.x?bigNumber:(this.end.y-this.start.y)/(this.end.x-this.start.x);
	var os=this.end.y-ds*this.end.x;
	var xc=(os-ob)/(db-ds);
	if(isNaN(xc)) console.log(" xc isNan : "+xc);
	var yc=xc*db+ob;//ds,os
	var ballDirectionTouchPoint = new Vector(xc,yc);
	var dn=this.normal.x==0?bigNumber:this.normal.y/this.normal.x;
	var on=pos2.y-dn*pos2.x;
	var ballOrthographicProjectionX=(os-on)/(dn-ds);
	var ballOrthographicProjectionY=ballOrthographicProjectionX*dn+on;//or ds,os
	var ballOrthographicProjection=new Vector(ballOrthographicProjectionX,ballOrthographicProjectionY);
	return {ballDirectionTouchPoint:ballDirectionTouchPoint,
			ballOrthographicProjection:ballOrthographicProjection,
			ballSpeed:ballSpeed};
}
Segment.prototype.testCollision = function(ball,pos1,pos2){
	var pdc=this.pointDeRencontre(pos1,pos2);
	var ballDirectionTouchPoint=pdc.ballDirectionTouchPoint;
	var ballOrthographicProjection=pdc.ballOrthographicProjection;
	var ballSpeed=pdc.ballSpeed;
	var distanceToBallOrthographicProjection = ballOrthographicProjection.clone().sub(pos2).getLength();
	
	//newSpeed vecteur speed
	var newSpeed=this.bounceVector(ballSpeed).multiplyScalar(ball.coeffRebond*this.coeffRebond);
	//repositionnement
	// Thalès dfppc:distance fp-pc,dfp: distance fp-seg -> d:distance centre ball au contact-pc
	var distanceToBallDirectionTouchPoint=ballDirectionTouchPoint.clone().sub(pos2).getLength();
	//var d=distanceToBallDirectionTouchPoint*(ball.radius+epsilon)/dfp;if(isNaN(d)) console.log(" d is NaN :",d);
	var d=distanceToBallDirectionTouchPoint*ball.radius/distanceToBallOrthographicProjection;
	if(isNaN(d)) console.log(" d is NaN :",d,distanceToBallOrthographicProjection,distanceToBallDirectionTouchPoint);
	//position balle au contact
	var ballPositionOnTouch=new Vector().copy(ballDirectionTouchPoint.clone().add(ballSpeed.clone().multiplyScalar(-1).setLength(d)));
	//var touchPoint = ballPositionOnTouch.clone().add(this.normal.clone().multiplyScalar(-(ball.radius+epsilon)));
	var touchPointOnBall = ballPositionOnTouch.clone().add(this.normal.clone().multiplyScalar(Math.sign(this.normal.dot(ballSpeed))*ball.radius));
	var v1=ballDirectionTouchPoint.clone().sub(pos1);
	var v2=ballDirectionTouchPoint.clone().sub(pos2);
	var dist=v1.getLength();
	var traverse=v1.dot(v2)<0;
	
	var sign=ballSpeed.getLength()<dist?-1:1;//devant ou derriere ?
	var diff=d+sign*distanceToBallDirectionTouchPoint;
	var newPos=ballPositionOnTouch.clone().add(newSpeed.clone().setLength(diff));
	
	var testDistance=distanceToBallOrthographicProjection<ball.radius;
	
	var test1=touchPointOnBall.x>(Math.min(this.start.x,this.end.x)-epsilon);
	var test2=touchPointOnBall.x<(Math.max(this.start.x,this.end.x)+epsilon);
	var test3=touchPointOnBall.y>(Math.min(this.start.y,this.end.y)-epsilon);
	var test4=touchPointOnBall.y<(Math.max(this.start.y,this.end.y)+epsilon);
	var touchPointOnBallIsBetweenStartAndEnd = test1&&test2&&test3&&test4;
	
	var startIsInBall = pos2.clone().sub(this.start).getLength() < ball.radius;
	var endIsInBall = pos2.clone().sub(this.end).getLength() < ball.radius;
	
	var ballCollision=testDistance&&(touchPointOnBallIsBetweenStartAndEnd||startIsInBall||endIsInBall);
	
	test1=ballDirectionTouchPoint.x>(Math.min(this.start.x,this.end.x)-ball.radius-epsilon);
	test2=ballDirectionTouchPoint.x<(Math.max(this.start.x,this.end.x)+ball.radius+epsilon);
	test3=ballDirectionTouchPoint.y>(Math.min(this.start.y,this.end.y)-ball.radius-epsilon);
	test4=ballDirectionTouchPoint.y<(Math.max(this.start.y,this.end.y)+ball.radius+epsilon);
	var ballDirectionTouchPointIsBetweenStartAndEnd = test1&&test2&&test3&&test4;
	var ballThrough=traverse&&ballDirectionTouchPointIsBetweenStartAndEnd;
	
	context.beginPath();
	drawBall(context,ball.position,ball.radius);
	context.fill();
	context.strokeStyle="green";
	drawBall2(pos2,ball.radius,"green");
	drawLine(ball.position,pos2,"blue");
	drawLine(pos2,ballOrthographicProjection,"red");
	drawBall2(ballPositionOnTouch,ball.radius,"red");
	drawBall2(touchPointOnBall,0.4*ball.radius,"green");
	
	drawBall2(ballDirectionTouchPoint,0.4*ball.radius,"yellow");
	//console.log(test);
	
	/*if(this.rebond&&test){
		ball.position.copy(np);
		ball.speed.copy(newSpeed);
	}*/
	//var ps=this.normal.x*ballSpeed.x+this.normal.y*ballSpeed.y;
	
	//if(frameCount<20) S("dbg").innerHTML = test1&&test2&&test3&&test4;
	return {hitNext:(ballCollision||ballThrough),positionOnTouch:ballPositionOnTouch,newPos:newPos,newSpeed:newSpeed};
}
//**** ****
function Ball(params){//rond
	DynamicObject.call(this,params);
	this.radius = params.radius || 0.05;
	this.coeffRebond=params.coeffRebond||1;
	//this.masse=0;
}
Ball.prototype = Object.create(DynamicObject.prototype);
Ball.prototype.constructor=Ball;
Ball.prototype.bounceOnSegment=function(segment,fp){//après test rebond, rebond à droite
	//modifie position et speed (et speedRotation)
	//ne pas soustraire futurepos et pos
	var pt1=segment.start;
	var pt2=segment.end;
	var touchPoint=segment.touchPoint;
	//sans radius pour l'instant
	//console.log(segment);
	//maj speed
	this.speed.add(segment.normal.clone().multiplyScalar(segment.normal.dot(this.speed)).multiplyScalar(-2));
	//position
	var lr=fp.clone().sub(pc).getLength();
	var np=touchPoint.clone().add(this.speed.clone().normalize().multiplyScalar(lr));
	this.position.set(np.x,np.y);
	
	return new Vector();//point de contact (centr balle)
}
function DynamicObject(params){//un truc qui peut bouger, connaissance du monde ou pas ?
	params=params||{position:new Vector()};
	this.position=params.position || new Vector();
	this.speed=params.speed||new Vector();
	this.speedMax=params.speedMax||0.2;//10% ecran
	this.acceleration= new Vector();//this.accelerationMax=params.accelerationMax||0.1;
	this.rotation=0;
	this.speedRotation=0;
}
DynamicObject.prototype.limit=function(axis,valMin,valMax){
	this.limits[axis].min=valMin;this.limits[axis].max=valMax;
}
DynamicObject.prototype.maj=function(){//split
	
	this.speed.add(this.acceleration);
	this.speed.y=clamp(this.speed.y,-this.speedMax,this.speedMax); 
	this.position.add(this.speed);
	this.position.y=clamp(this.position.y,this.limits.y.min+this.dimensions.y/2,this.limits.y.max-this.dimensions.y/2);//dim ?
}
DynamicObject.prototype.majAccel=function(a){
	this.acceleration.copy(a);
}
DynamicObject.prototype.ralentir=function(){
	this.speed.multiplyScalar(0.85);
	if(this.speed.getLength()<0.002) this.speed.zero();
	this.acceleration.multiplyScalar(0.85);
	if(this.acceleration.getLength()<0.002) this.acceleration.zero();
}
//*** *** ***
function Obstacle(params){//rectangle ou polygone, n segments 1<=n
	params=params||{};
	DynamicObject.call(this,params);
	this.dimensions=params.dimensions||new Vector();
	this.segments=[];//maj
}
Obstacle.prototype = Object.create(DynamicObject.prototype);
Obstacle.prototype.constructor=Obstacle;
Obstacle.prototype.majSegments=function(pos0,pos1){//position actuelle, position future
	
}

//*** ******
function Player(number,id,ids){
	this.nom = "Player"+number;
	this.racket=new Obstacle({speedMax:pong.config.racket.speedMax}); //DynamicObject, dimensions, angle
	
	this.playingPosition=undefined;//placé quand entre en jeu
	this.score=0;
	
	this.id=id;
	this.playing=false;
}
//*** ** ***
function compareId(id){
	return function(el){return el.id===id;}
}
function clamp(x,xmin,xmax){return Math.min(xmax,Math.max(xmin,x));}
function distance(a,b){var dx=b.x-a.x,dy=b.y-a.y;return Math.sqrt(dx*dx+dy*dy);}
function cos(a,b){return (a.position.x-b.position.x)/(a.position.y-b.position.y);}

function Point(x,y){this.x=x||0;this.y=y||0;}
Point.prototype.constructor=Point;

function Vector(x,y){this.x=x||0;this.y=y||0;}
Vector.prototype.getLength=function(){return Math.sqrt(this.x*this.x+this.y*this.y);}
Vector.prototype.getSqLength=function(){return this.x*this.x+this.y*this.y;}
Vector.prototype.setLength=function(leng){return this.normalize().multiplyScalar(leng);}
Vector.prototype.zero=function(){this.x=0;this.y=0;return this;}
Vector.prototype.randomize=function(){this.x=-1+2*Math.random();this.y=-1+2*Math.random();return this;}
Vector.prototype.set=function(x,y){this.x=x;this.y=y; return this;}
Vector.prototype.normalize=function(){var d = this.getLength();if(d!==0){return this.multiplyScalar(1/d);}else{return this.zero();}}
Vector.prototype.add=function(p){this.x+=p.x;this.y+=p.y;return this;}
Vector.prototype.sub=function(p){this.x-=p.x;this.y-=p.y;return this;}
Vector.prototype.multiplyScalar=function(s){this.x*=s;this.y*=s;return this;}
Vector.prototype.multiply=function(p){this.x*=p.x;this.y*=p.y;return this;}
Vector.prototype.angle=function(){var angle = Math.atan2( this.y, this.x );if ( angle < 0 ) angle += 2 * Math.PI;return angle;}
Vector.prototype.rotate=function(angle){return this.rotateAround(new Vector(),angle);}
Vector.prototype.rotateAround = function ( center, angle ) {
		var c = Math.cos( angle ), s = Math.sin( angle );
		var x = this.x - center.x;
		var y = this.y - center.y;
		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;
		return this;
}
Vector.prototype.dot=function(p){
	return this.x*p.x+this.y*p.y;
}
Vector.prototype.getVectorFromAngle=function(a){
	this.x=Math.cos(a);this.y=Math.sin(a);return this;
}
Vector.prototype.getMiddle=function(v1,v2){
	this.x=(v1.x+v2.x)/2;this.y=(v1.y+v2.y)/2;return this;
}
Vector.prototype.copy=function(p){this.x=p.x;this.y=p.y;return this;}
Vector.prototype.clone=function(){return new this.constructor(this.x,this.y);}

Vector.prototype.constructor=Vector;
//*** ** ***
function iRandom(n){return Math.floor(n*Math.random());}
function S(x){return document.getElementById(x);}
start();
</script>
</body>
</html>
